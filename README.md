Rever
=====

Rever is a work-in-progress reversible programming language. Examples of other such languages include [Janus](https://en.wikipedia.org/wiki/Janus_(time-reversible_computing_programming_language)) and [rFun](http://topps.diku.dk/pirc/?id=rfun).

<!-- [Bob](https://link.springer.com/chapter/10.1007/978-3-642-29517-1_3). -->


Intro
-----

What is reversible computing?

[Reversible computing](https://en.wikipedia.org/wiki/Reversible_computing) is a special type of computation where any steps taken can be easily reversed. The idea is to preserve information in order to reduce the amount of heat generated by a computer, since [more wasted bits means more heat](https://en.wikipedia.org/wiki/Landauer%27s_principle). It also reduces the amount of code needed by half.

Steps often require a separate *dual* action to undo the original action. This is also called an *invertion*. For example, adding a number can only be undone by subtracting the same number again. Even the very notion of reversing requires a dual: you must specify whether you want to *do* an action, or *undo* it.

Some steps can be reversed by doing the same action again. Examples include negating a number or the NOT gate. In this case, the action is its own inverse. These are called [involutions](https://en.wikipedia.org/wiki/Involution_(mathematics)).

As a result, irreversible actions are kept to a minimum. Reversible computers can still do all the same things irreversible computers can, but tend to produce what's called "garbage" — data that's considered irrelevant (and usually unwanted) from the desired result. If it's absolutely necessary for computing a value however, the garbage can be kept and then used to *uncompute* the value after it's been safely copied, producing no waste.

By the way, in reversible computing "to copy" or "to set" refers to the act of XORing a value to a zero-initialized memory location, and "to clear" or "to reset" refers to XORing a value to a memory location with the same value. There is no assignment statement. It would be irreversible. What happens if the memory location is neither of those values? Bad things.

Here, I'll show how certain parts of reversible computing work in general while giving examples in Rever. Then I'll go into some features in Rever.


Control flow
------------

Reversibility can be extended to conditionals, loops, and procedures.

**Conditionals** can have at most 4 parts: the test, a code block, an optional else-block, and an assertion. The conditional is reversed by having the assertion become the test and *vice versa* when it is run in reverse. Nothing else changes.

```
if a = b then
    a += b    // a' = a + b = b + b = 2b
else
    a -= b
fi a = 2*b
```

**Loops** are a bit more complicated to describe. They have an assertion, a do-block or a loop-block (or both), and a test. The initial assertion can only be true when going into the loop; it *must* be false afterwards while looping. After the initial assertion, the do-block is executed. Then the test is evaluated to determine if the loop should continue. If the test is false, the loop-block gets executed, the assertion is checked to be false, and the do-block is executed again, and so on until the test returns true. Like conditionals, the test and assertion are swapped when going in reverse. Nothing else changes.

The reason there are two blocks is to give the flexibility of running the test before actually executing code, or have code that runs only after the test fails.

```
// i goes from 0 to 100 (exclusive)
from i = 0 do
    a += i
    i += 1
until i = 100

// i goes from 0 to 100 (inclusive)
from i = 0 do
    a += i
loop
    i += 1
until i = 100
```

**Assertions** should allow a statement running in reverse to determine which branch to run (for conditionals) or what the starting condition is (in loops).

In conditionals, they should reflect what changes the first code block made to the variables. If the variables being tested aren't changed in either branch of code, then you can safely have the assertion be the same as the test. If variables in the test *are* being changed, the assertion *cannot* be the same as the test, and must reliably choose which branch should execute when going in reverse.

In loops, the assertion can be the end value of the iterating variable, or a predicate that depends on any variable whose value depends on the loop.

### `for`s, `when`s, and `match`s

It can become a bit tedious (and error-prone!) to repeat expressions multiple times in different places. That's why some alternate control structures are being considered for some special-case code. These consist of `for`, `when`, and `match`.

Instead of writing
```
if a = b or b = c and c = d then
    // ...
else
    // ...
fi a = b or b = c and c = d
```

…and risk getting the assertion wrong, you could instead use
```
when a = b or b = c and c = d then
    // ...
end
```

A similar structure, `match`, would also be useful when there's more than 1 value being tested.

Instead of
```
when a = b then
    // ...
else when a = c
    // ...
else when a = d
    // ...
end
end
end
```

you can write something like this (syntax subject to change):
```
match a with
    | b then // ... end
    | c then // ... end
    | d then // ... end
    // ...
    | _ then // ... end
end
```


Procedures
----------

In math, reversible functions must have the same number of values in their output as they do in their input. Procedures follow a similar rule, except instead of returning explicit tuples, for convenience the variables *themselves* are modified when passed. If it helps, another way of thinking about it is that procedures always pass-by-reference.

Procedures are reversed by reversing the order of its statements and inverting them. Any increments become decrements, decrements become increments, conditionals and loops are inverted, and so on. When calling a procedure, the method of call determines whether it's run forwards or backwards. In Rever, a procedure is called using either `do` or `undo` as a preceding keyword to the actual call.

```
proc add(var a: i32, b: i32) {
    a += b
}

var a = 11
do add(a, 3)   // a = 14
undo add(a, 14) // a = 0
```

Recursion is also allowed.

```
// a fibonacci number generating procedure
proc fib(var x1: i32, var x2: i32, var n: i32) {
    if n = 0 then
        x1 ^= 0
        x2 ^= 1
    else
        n -= 1
        do fib(x1, x2, n)
        x1 += x2
        x1 <> x2
    fi x1 = 0 and x2 = 1
}
```

### Functions

A (planned) feature of Rever is to allow a special type of procedure called a function. It differs from typical procedures in that they can return a single value and can be used in expressions. You may have heard of them.

To achieve this, all parameters are immutable and a special keyword `return` is used as a variable name to represent the value that will be returned. The initial value of `return` will be either its specified default value (if any) or a zero-initialized value (subject to change on actual implementation).

To prevent unexpected side-effects from occurring in expressions, all parameters in functions are immutable and no outside variables can be accessed.

```
proc mul(a: i32, b: i32, var r: i32) {
    var i = 0
    from i = 0 do
        if b ^ (1 << i) != 0 then
            r += a << i
        fi b ^ (1 << i) != 0
        i += 1
    until i = 32
    drop i = 32
}
// ...is functionally equivalent to...
fn mul(a: i32, b: i32): i32 {
    var i = 0
    from i = 0 do
        if b ^ (1 << i) != 0 then
            return += a << i
        fi b ^ (1 << i) != 0
        i += 1
    until i = 32
    drop i = 32
}

// except you can use it in expressions!
var a = 3
var b = 10
// ...
if mul(a, b) = 30 then
    // ...
fi mul(a, b) = 30
```

