Rever
=====

Rever is a reversible programming language. It features ["copy-in copy-out"] semantics, a minimal Pascal-like syntax, and procedures & functions.

Examples of other such reversible languages include [Janus](https://en.wikipedia.org/wiki/Janus_(time-reversible_computing_programming_language)) and [rFun](http://topps.diku.dk/pirc/?id=rfun).

<!-- [Bob](https://link.springer.com/chapter/10.1007/978-3-642-29517-1_3). -->


Installation
------------

First, install [Rust](https://www.rust-lang.org/tools/install). Then, download the ZIP file for this project, unzip it, `cd` into the directory, and run:

    cargo install --path .

Currently the tool only parses a file and outputs an AST to the console. You can process a file by running `rever <file>`. Try some of the examples in the `examples/` folder!


What is reversible computing?
-----------------------------

[Reversible computing](https://en.wikipedia.org/wiki/Reversible_computing) is a special type of computation where any steps taken can be easily and trivially reversed. The idea is to preserve information in order to reduce the amount of heat generated by a computer, since [more wasted bits means more heat](https://en.wikipedia.org/wiki/Landauer%27s_principle). However, it also reduces the amount of code needed by half (due to the reuse of code in the opposite direction),

Irreversible actions are kept to a minimum. Reversible computers can still do all the same things irreversible computers can, but tend to produce "garbage" â€” data that is a by-product from computing a result. However, the garbage can be kept and then used to *uncompute* the value after it's been safely copied, producing no waste.

Please keep in mind that although Rever makes every attempt to keep garbage to a minimum, it cannot guarantee that the code you write will not be garbage. In order to reduce any uncertainty regarding this, we recommend assuming that any and all code is garbage.


What's Rever like?
-------------------

Rever prefers to use newlines and keywords (e.g. `end`, `fi`) rather than braces to denote blocks. It may have significant *newlines*, but don't worry, it doesn't distinguish between spaces and tabs.

A Rever file consists of *items*, which include procedures, functions, types, modules, etc. They are much like those in Rust.

We'll start by learning the simplest statements first, and then work our way up.

### Tutorial

The most trivial statement is `skip`. It does absolutely nothing. However, you'll sometimes need it since some parts of the language don't accept an empty block, or when you want to be explicit that nothing should be done in some cases.

Next come the modifying assignments. These include increment (`+=`), decrement (`-=`), and xor-assign (`:=`). They each do what their names say.

	sum += 4
	name.len -= 1 + sum
	hash[0] := 3

There's also swap (`<>`), which takes 2 variables and swaps their values.

	nums[i] <> nums[last]

Now we get into the interesting stuff: procedure calls. You can either call a procedure (`do`) to run it forwards, or uncall a procedure (`undo`) to run it backwards. They both have 3 forms that you can use depending on the number of parameters the procedure has or whether you want a multiline call.

	do subtask
	do print: "hello world!"
	do something(
		f(x) + 3,
		name
	)

(Note: procedures are always called with "in-out" parameters, which means that when the procedure finishes, the final value of the parameters will be copied back to the caller.)

<!-- TODO: var-drop section -->

If-else branches can have at most 4 parts: the test, the code block to run if it passes, an optional else-block, and an optional assertion. Only the assertion and test are swapped when running backwards. The value of the assertion *must* match the value of the test at the end of the branch. If the assertion is not given, it's assumed to be the same as the test. Note that this is *not always* what you may want.

	if a = 0
		b += 1
	fi
	
	# same as above
	if a = 0
		b += 1
	fi a = 0
	
	# omitting assertion wouldn't work here
	if a = b
		a += b
	else
		a -= b
	fi a = 2*b

If any variables being checked could change while in the branch, you *will* have to write an assertion.

Loops are a bit more complicated. They have an assertion at the beginning, a do-block or a back-block (or both), and a test. The initial assertion can only be true at the start, and *must* be false while looping. The do-block is then executed. After that, the test is evaluated to see if the loop should stop. If the test is true, we exit the loop. Otherwise, the back-block is executed, the assertion is checked to be false, and it loops back again to running the do-block. Like conditionals, only the test and assertion are swapped when going in reverse.

	# i goes from 0 to 5 (exclusive)
	from i = 0
		do println: "hi"
		i += 1
	until i = 5 end

	# i goes from 0 to 5 (inclusive)
	from i = 0
		do println: "hi"
	until i = 5
		i += 1
	end

The back-block gives the flexibility of running the test before actually executing code, or to have code that runs only after the test fails.

### Note about assertions

Assertions should allow a statement running in reverse to determine which branch to take for conditionals or what the starting condition is in loops.

In conditionals, they should reflect what changes the first code block made to the variables. If the variables being tested aren't changed in either branch of code, then you can safely have the assertion be the same as the test. If variables in the test *are* being changed, the assertion *cannot* be the same as the test, and must reliably choose which branch should execute when going in reverse.

In loops, the assertion can be the end value of the iterating variable, or a predicate that depends on any variable whose value depends on the loop.


Procedures and Functions
------------------------

Rever has both procedures and functions.

**Procedures** run a series of statements, optionally taking a list of arguments. Parameters are called in a "move-in move-out" fashion, similar to ["copy-in copy-out"]. This means that, if a procedure marks one of its parameters as mutable, then the value of the variable given to that parameter by the caller could change after the procedure is called. Procedures also can't return values and therefore can't be used in expressions.

**Functions** evaluate a list of immutable arguments and return a value. This means that a function can be used in expressions. Unlike procedures, functions cannot have side-effects; variables outside of their scope are not accessible.

When a procedure is called using `undo`, it is reversed by inverting its statements and then reversing their order. Any increments become decrements (and vice versa), conditionals and loops are inverted, and so on. Only statements are inverted, not expressions.

In functions, the special keyword `return` can be used as the name for the value that will be returned. The initial value of `return` will be either its specified default value (if any) or a zero-initialized value (subject to change on actual implementation).

### Why not just have procedures?

The answer is that procedures and functions have some properties that are mutually incompatible if we want to maintain the property of reversibility. Consider mutable parameters: if functions had them, we wouldn't be able to guarantee  anymore because functions are sometimes run more than once in order to verify a state (e.g. using the same function in the `if` and `fi` sections of a branch). This could result in code that only runs in one direction but not another, or side-effects that show up twice.


Features under consideration
----------------------------

It can become a bit tedious (and error-prone!) to repeat expressions multiple times in different places. That's why some alternate control structures are being considered for some special-case code. These consist of `for`, and `match`.

### Chained comparisons

*A la* Python:

```
if a = 0
    do something
fi b > c

if start <= x <= end
    do something
fi
```

### Special boolean operators

In the same vein as chained comparisons, instead of using `&&` for AND and `||` for OR as short-circuiting boolean operators, we can have special syntax in the conditional statement.

```
if a > x > b, x != 0; x = 1
    do something
fi
```

This would be the same as `a = b && c > d || a != d` in C-like languages. `and` and `or` can be used when short-circuiting is desired, while the special syntax can behave like in Pascal.

### `match` blocks

A pattern-matching statement like `match` would be useful when a variable is being checked for multiple values.

Instead of
```
if a = b
    do something1
else if a = c
    do something2
else if a = d
    # ...
fi
fi
fi
```

you can write something like this (syntax subject to change):
```
match a
    b -> 1
    c -> 2
    d -> 3
    # ...
    _ -> 0
end
```

### `for` loops

A common case for loops is to iterate through a range of numbers, a list of items, etc. So a `for` loop is being considered:

```
for i in 0..100   # for numbers
    do something
end

for i in list     # for finite lists
    do something
end
```

["copy-in copy-out"]: https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_copy-restore

