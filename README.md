Rever
=====

Rever is a reversible programming language. It features ["copy-in copy-out"] semantics, a Ruby-like syntax, 

Examples of other such reversible languages include [Janus](https://en.wikipedia.org/wiki/Janus_(time-reversible_computing_programming_language)) and [rFun](http://topps.diku.dk/pirc/?id=rfun).

It's goals are to be:
+ easy to pick up and use
+ reversible

<!-- [Bob](https://link.springer.com/chapter/10.1007/978-3-642-29517-1_3). -->


Installation
------------

First, install [Rust](https://www.rust-lang.org/tools/install). Then, download the ZIP file for this project, unzip it, `cd` into the directory, and run `cargo install --path .`.

Currently the tool only parses a file and outputs an AST to the console. You can process a file by running `rever <file>`. Try some of the examples in the `examples/` folder!


What is reversible computing?
-----------------------------

[Reversible computing](https://en.wikipedia.org/wiki/Reversible_computing) is a special type of computation where any steps taken can be easily and trivially reversed. The idea is to preserve information in order to reduce the amount of heat generated by a computer, since [more wasted bits means more heat](https://en.wikipedia.org/wiki/Landauer%27s_principle). It also reduces the amount of code needed by half in some cases, due to the reuse of code in the opposite direction.

An action can sometimes require a *dual* action to undo the original action. For example, adding a number can only be undone by subtracting the same number. Even the very notion of reversing requires a dual: you must specify whether you want to *do* an action, or *undo* it.

Some steps can be reversed by doing the same action again. Examples include negating a number, or XORing a variable with a value. In these cases, the action is its own inverse, making it an [involution](https://en.wikipedia.org/wiki/Involution_(mathematics)).

Irreversible actions are kept to a minimum. Reversible computers can still do all the same things irreversible computers can, but tend to produce "garbage" â€” data that is a by-product from computing a result. However, the garbage can be kept and then used to *uncompute* the value after it's been safely copied, producing no waste. This allows expressions to be possible despite being irreversible sometimes.

Please keep in mind that although Rever makes every attempt to keep garbage to a minimum, it cannot guarantee that the code you write will not be garbage. In order to reduce any uncertainty regarding this, we recommend assuming that any and all code is garbage.

In reversible computing, "to copy" or "to set" refers to the act of XORing a value to a zero-initialized memory location, and "to clear" or "to reset" refers to XORing a value to a memory location with the same value, zeroing the memory. There is no assignment statement because it would be irreversible. What happens if the memory location is neither zero nor the same value? Bad things.


Control flow
------------

Reversibility can be extended to conditionals, loops, and procedures.

**Conditionals** can have at most 4 parts: the test, a code block, an optional else-block, and an assertion. The test and assertion are swapped when running the conditional in reverse. Nothing else changes.

```
if a = b
    a += b    // a' = a + b = b + b = 2b
else
    a -= b
fi a = 2*b
```

**Loops** are a bit more complicated. They have an assertion, a do-block or a loop-block (or both), and a test. The initial assertion can only be true at the start; it *must* be false afterwards while looping. The do-block is then executed. After that, the test is evaluated to check if the loop should continue. If the test is true, we exit the loop. If it's false, the loop-block is executed, the assertion is checked to be false, and loop back again to running the do-block. Like conditionals, the test and assertion are swapped when going in reverse.

The reason there are two blocks is to give the flexibility of running the test before actually executing code, or to have code that runs only after the test fails.

```
// i goes from 0 to 100 (exclusive)
from i = 0
    a += i
    i += 1
until i = 100 end

// i goes from 0 to 100 (inclusive)
from i = 0
    a += i
until i = 100
    i += 1
end
```

**Assertions** should allow a statement running in reverse to determine which branch to run (for conditionals) or what the starting condition is (in loops).

In conditionals, they should reflect what changes the first code block made to the variables. If the variables being tested aren't changed in either branch of code, then you can safely have the assertion be the same as the test. If variables in the test *are* being changed, the assertion *cannot* be the same as the test, and must reliably choose which branch should execute when going in reverse.

In loops, the assertion can be the end value of the iterating variable, or a predicate that depends on any variable whose value depends on the loop.


Procedures and Functions
------------------------

Rever has both procedures and functions.

**Procedures** run a series of statements, optionally taking a list of arguments. Parameters are called in a "move-in move-out" fashion, similar to ["copy-in copy-out"]. This means that, if a procedure marks one of its parameters as mutable, then the value of the variable given to that parameter by the caller could change after the procedure is called. Procedures also can't return values and therefore can't be used in expressions.

**Functions** evaluate a list of immutable arguments and return a value. This means that a function can be used in expressions. Unlike procedures, functions cannot have side-effects; variables outside of their scope are not accessible.

When a procedure is called using `undo`, it is reversed by inverting its statements and then reversing their order. Any increments become decrements (and vice versa), conditionals and loops are inverted, and so on. Only statements are inverted, not expressions.

In functions, the special keyword `return` can be used as the name for the value that will be returned. The initial value of `return` will be either its specified default value (if any) or a zero-initialized value (subject to change on actual implementation).

### Definition

```
proc add(var a: u8, b: u8)
    a += b
end

fn mul(a: u8, b: u8): u8
    a * b
end

proc hello
    do print "Hello world!"
end
```

### Call

```
var c := mul(3, 2)  # c = 6

do add(c, 1)      # usual form, multiline
do add c, 1       # terse form
```

Recursion is also allowed.

```
 # a fibonacci number generating procedure
proc fib(var x1: u8, var x2: u8, var n: u64)
    if n = 0
        x1 := 0
        x2 := 1
    else
        n -= 1
        do fib x1, x2, n
        x1 += x2
        x1 <> x2
    fi x1 = 0, x2 = 1
end

 # in function form
fn fib(n: i32): i32
    if n = 0
        0
    else if n = 1
        1
    else
        fib(n - 1) + fib(n - 2)
    end
end

 # similar to
proc fib(n: u32, var return: u32)
    if n = 0
        return := 0
    else if n = 1
        return := 1
    else
        let left := 0
        let right := 0
        do fib(n - 1, left)
        do fib(n - 2, right)
        return := left + right
        undo fib(n - 2, right)
        undo fib(n - 1, left)
        drop right := 0
        drop left := 0
    fi n = 1
    fi n = 0
end
```

### Rationale

You may be asking "why can't we just use functions all the time?", which is a good question.

The answer is that procedures and functions have some properties that are mutually incompatible if we want to maintain the property of reversibility. Consider the mutable parameters of procedures; if functions had them, they wouldn't be usable in expressions anymore because functions are sometimes run twice in order to verify a state (e.g. using the same function in the `if` and `fi` sections of a branch). This could result in code that only runs in one direction but not another, or side-effects that show up twice.


Features under consideration
----------------------------

It can become a bit tedious (and error-prone!) to repeat expressions multiple times in different places. That's why some alternate control structures are being considered for some special-case code. These consist of `for`, `when`, and `match`.

### Chained comparisons

*A la* Python

```
if a = 0
    do something
fi b > c

if start <= x <= end
    do something
end
```

### Special boolean operators

In the same vein as chained comparisons, instead of using `&&` for AND and `||` for OR as short-circuiting boolean operators, we can have special syntax in the conditional statement.

```
if a > x > b, x != 0; x = 1
    do something
end
```

This would be the same as `a = b && c > d || a != d` in C-like languages. `and` and `or` can be used when short-circuiting is desired, while the special syntax can behave like in Pascal.

### `match` blocks

A pattern-matching statement like `match` would be useful when a variable is being checked for multiple values.

Instead of
```
if a = b
    do something1
else if a = c
    do something2
else if a = d
    # ...
end
end
end
```

you can write something like this (syntax subject to change):
```
match a
    b -> 1
    c -> 2
    d -> 3
    # ...
    _ -> 0
end
```

### `for` loops

A common case for loops is to iterate through a range of numbers, a list of items, etc. So a `for` loop is being considered:

```
for i in 0..100   # for numbers
    do something
end

for i in list     # for finite lists
    do something
end
```

["copy-in copy-out"]: https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_copy-restore

