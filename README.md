Rever
=====

Rever is a work-in-progress reversible programming language. Examples of other such languages include [Janus](https://en.wikipedia.org/wiki/Janus_(time-reversible_computing_programming_language)) and [rFun](http://topps.diku.dk/pirc/?id=rfun).

<!-- [Bob](https://link.springer.com/chapter/10.1007/978-3-642-29517-1_3). -->


What is reversible computing?
-----------------------------

[Reversible computing](https://en.wikipedia.org/wiki/Reversible_computing) is a special type of computation where any steps taken can be easily reversed. The idea is to preserve information in order to reduce the amount of heat generated by a computer, since [more wasted bits means more heat](https://en.wikipedia.org/wiki/Landauer%27s_principle). It also reduces the amount of code needed by half.

Steps often require a separate *dual* action to undo the original action. This is also called an *invertion*. For example, adding a number can only be undone by subtracting the same number again. Even the very notion of reversing requires a dual: you must specify whether you want to *do* an action, or *undo* it.

Some steps can be reversed by doing the same action again. Examples include negating a number, or the NOT gate. In these cases, the action is its own inverse. These are called [involutions](https://en.wikipedia.org/wiki/Involution_(mathematics)).

As a result, irreversible actions are kept to a minimum. Reversible computers can still do all the same things irreversible computers can, but tend to produce what's called "garbage" — data that's considered irrelevant (and usually unwanted) from the desired result. If it's absolutely necessary for computing a value however, the garbage can be kept and then used to *uncompute* the value after it's been safely copied, producing no waste.

In reversible computing, "to copy" or "to set" refers to the act of XORing a value to a zero-initialized memory location, and "to clear" or "to reset" refers to XORing a value to a memory location with the same value, zeroing the memory. There is no assignment statement because it would be irreversible. What happens if the memory location is neither zero nor the same value? Bad things.

Here, I'll show how certain parts of reversible computing work in general while giving examples in Rever. Then I'll go into some features that are unique to Rever.


Control flow
------------

Reversibility can be extended to conditionals, loops, and procedures.

**Conditionals** can have at most 4 parts: the test, a code block, an optional else-block, and an assertion. The test and assertion are swapped when running the conditional in reverse. Nothing else changes.

```
if a = b then
    a += b    // a' = a + b = b + b = 2b
else
    a -= b
fi a = 2*b
```

**Loops** are a bit more complicated. They have an assertion, a do-block or a loop-block (or both), and a test. The initial assertion can only be true at the start; it *must* be false afterwards while looping. The do-block is then executed. After that, the test is evaluated to check if the loop should continue. If the test is true, we exit the loop. If it's false, the loop-block is executed, the assertion is checked to be false, and loop back again to running the do-block. Like conditionals, the test and assertion are swapped when going in reverse.

The reason there are two blocks is to give the flexibility of running the test before actually executing code, or to have code that runs only after the test fails.

```
// i goes from 0 to 100 (exclusive)
from i = 0 do
    a += i
    i += 1
until i = 100

// i goes from 0 to 100 (inclusive)
from i = 0 do
    a += i
loop
    i += 1
until i = 100
```

**Assertions** should allow a statement running in reverse to determine which branch to run (for conditionals) or what the starting condition is (in loops).

In conditionals, they should reflect what changes the first code block made to the variables. If the variables being tested aren't changed in either branch of code, then you can safely have the assertion be the same as the test. If variables in the test *are* being changed, the assertion *cannot* be the same as the test, and must reliably choose which branch should execute when going in reverse.

In loops, the assertion can be the end value of the iterating variable, or a predicate that depends on any variable whose value depends on the loop.


Procedures
----------

In math, reversible functions must have the same number of values in their output as they do in their input. Thus procedures follow a similar rule, except instead of explicitly returning a tuple of values, values are *moved* when called (rather than copied) and *moved back* when the procedure is done.

Procedures are reversed by reversing the order of its statements and inverting them. Any increments become decrements (and vice versa), conditionals and loops are inverted, and so on. However, it's worth noting that **expressions are not inverted** when going in reverse, only statements.

When calling a procedure, the method of call determines whether it's run forwards or backwards. In Rever, a procedure is called using either `do` or `undo` as a preceding keyword to the actual call.

```
proc add(var a: i32, b: i32) {
    a += b
}

var a = 11
do add(a, 3)    // a = 14
undo add(a, 14) // a = 0
```

Recursion is also allowed.

```
// a fibonacci number generating procedure
proc fib(var x1: i32, var x2: i32, var n: i32) {
    if n = 0 then
        x1 ^= 0
        x2 ^= 1
    else
        n -= 1
        do fib(x1, x2, n)
        x1 += x2
        x1 <> x2
    fi x1 = 0 and x2 = 1
}
```

### Functions

A (planned) feature of Rever is to allow a special type of procedure called a function. It differs from typical procedures in that they can return a single value and can be used in expressions. You may have heard of them.

To achieve this, all parameters are kept immutable and a special keyword `return` is used as a variable name to represent the value that will be returned. The initial value of `return` will be either its specified default value (if any) or a zero-initialized value (subject to change on actual implementation).

```
proc mul(a: i32, b: i32, var r: i32) {
    var i = 0
    from i = 0 do
        if b ^ (1 << i) != 0 then
            r += a << i
        fi b ^ (1 << i) != 0
        i += 1
    until i = 32
    drop i = 32
}
// ...is functionally equivalent to...
fn mul(a: i32, b: i32): i32 {
    var i = 0
    from i = 0 do
        if b ^ (1 << i) != 0 then
            return += a << i
        fi b ^ (1 << i) != 0
        i += 1
    until i = 32
    drop i = 32
}

// except you can use it in expressions!
var a = 3
var b = 10
// ...
if mul(a, b) = 30 then
    // ...
fi mul(a, b) = 30
```


Features under consideration
----------------------------

It can become a bit tedious (and error-prone!) to repeat expressions multiple times in different places. That's why some alternate control structures are being considered for some special-case code. These consist of `for`, `when`, and `match`.

### `when` blocks

Instead of writing
```
if a = b or b = c and c = d then
    // ...
else
    // ...
fi a = b or b = c and c = d
```

…and risk getting the assertion wrong, you could instead write
```
when a = b or b = c and c = d then
    // ...
end
```

and not have to worry about the test and assertion mismatching. Some analysis could also be done so that variables in the test aren't being modified in the code block.

### `match` blocks

A similar structure, `match`, would also be useful when there's more than 1 value being tested.

Instead of
```
when a = b then
    // ...
else when a = c
    // ...
else when a = d
    // ...
end
end
end
```

you can write something like this (syntax subject to change):
```
match a with
    | b then // ... end
    | c then // ... end
    | d then // ... end
    // ...
    | _ then // ... end
end
```

### `for` loops

A common case for loops is to iterate through a range of numbers, a list of items, etc. So a `for` loop is being considered:

```
// for numbers
for i in 0..100 do
    // ...
loop
    // ...
done

// for a list?

for i in list do
    // ...
loop
    // ...
done
```
